from collections import namedtuple

ErrorResult = namedtuple("ErrorResult", "Message")

test = ErrorResult(Message = "THIS IS A TEST")

match def checkResult(result, if isinstance(result, ErrorResult)) = result

@addpattern(checkResult)
def calc_1(result):
    # if isinstance(result, ErrorResult):
    #     print ("error calc_1")
    #     return result
    # else:
    # do something with the result
    print ("calculating calc_1")
    return result * 100

@addpattern(checkResult)
def calc_2(result):
    # if isinstance(result, ErrorResult):
    #     print ("error calc_2")
    #     return result
    # else:
    # do something with the result
    print ("calculating calc_2")
    return result * 200

@addpattern(checkResult)
def calc_error(result):
    # FORCE AN ERROR FOR THIS EXAMPLE
    print ("returning an error")
    return test

# calc_1(test) |> print
# calc_2(test) |> print

# calc_error(1) |> print

#NOW we can build a pipeline and short circuit any processing if an error occured

#this chouls produce the error result
1 |> calc_1 |> calc_error |> calc_2 |> print
# pipe 1 into calc_1
# calc_error will result in an ErrorResult
# calc_2 will not do any calculation, but will return the ErrorResult from the previous calculation
# print

1 |> calc_1 |> calc_2 |> calc_2 |> print

